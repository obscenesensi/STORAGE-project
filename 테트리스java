import java.awt.*;import java.io.*;class Square { int x, y, c;      //x좌표, y좌표, 색깔  Square(int x, int y, int c) {  this.x = x;  this.y = y;  this.c = c; } int X() { return x; } int Y() { return y; } int Color() { return c; } boolean InBounds() {     // 게임영역   return (x >= 0 && x < Tetris.cols && y >= 0 && y < Tetris.rows + 4); } boolean IsEqual(Square s) {  return x == s.x && y == s.y && c == s.c; }} //  위로 public class Tetris extends java.applet.Applet implements Runnable{ static   int sqlength;          // square 사각형 길이 static final int xoffset = 200; // 왼쪽부터 거리 static   int cols;              // columns static   int rows;              // rows int  f[][];int  of[][];int  what;                          // 현재조각의 타입 Square  curpiece[] = new Square[4]; // 현재조각 boolean  lost;boolean  neednewpiece;Thread  killme = null;Color  colors[];int  curval, score = 0;int  level;    // 현재의 게임단계 int  pieces;   // 떨어진 조각의 수 String   highscorehost;short    highscoreport;boolean  blackwhite;         // 흑백 boolean  suspended = false;boolean  justupdating = false;//  위로  // 조각의 이동 private boolean movepiece(Square from[], Square to[]) {outerlabel: for (int i = 0; i<to.length; i++) {  if (!to[i].InBounds()) { return false; }  if (f[to[i].X()][to[i].Y()] != 0) {   for (int j = 0; j<from.length; j++)    if (to[i].IsEqual(from[j])) {     continue outerlabel;    }   return false; // 이동 불가   } } // blank old piece  for (int i = 0; i<from.length; i++)  if (from[i].InBounds()) {   f[from[i].X()][from[i].Y()] = 0;  } // 새로운 조각 표시  for (int i = 0; i<to.length; i++)  f[to[i].X()][to[i].Y()] = to[i].Color(); return true;} //  위로   // 새로운 조각 private void newpiece() { Square  old[] = new Square[4]; old[0] = old[1] = old[2] = old[3] = new Square(-1, -1, 0); int m = cols / 2; what = (int)(Math.random() * 7); switch (what) { case 0:  // XXXX   curval = 100;  curpiece[0] = new Square(m - 1, rows - 1, 1);  curpiece[1] = new Square(m - 2, rows - 1, 1);  curpiece[2] = new Square(m,   rows - 1, 1);  curpiece[3] = new Square(m + 1, rows - 1, 1);  break; case 1:  //  X   // XXX   curval = 120;  curpiece[0] = new Square(m  , rows - 2, 5);  curpiece[1] = new Square(m  , rows - 1, 5);  curpiece[2] = new Square(m - 1, rows - 2, 5);  curpiece[3] = new Square(m + 1, rows - 2, 5);  break; case 2:  // XX   //  XX   curval = 180;  curpiece[0] = new Square(m  , rows - 2, 2);  curpiece[1] = new Square(m - 1, rows - 1, 2);  curpiece[2] = new Square(m  , rows - 1, 2);  curpiece[3] = new Square(m + 1, rows - 2, 2);  break; case 3:  //  XX   // XX   curval = 180;  curpiece[0] = new Square(m  , rows - 2, 7);  curpiece[1] = new Square(m + 1, rows - 1, 7);  curpiece[2] = new Square(m  , rows - 1, 7);  curpiece[3] = new Square(m - 1, rows - 2, 7);  break; case 4:  //  XX   //  XX   curval = 100;  curpiece[0] = new Square(m - 1, rows - 1, 3);  curpiece[1] = new Square(m  , rows - 1, 3);  curpiece[2] = new Square(m - 1, rows - 2, 3);  curpiece[3] = new Square(m  , rows - 2, 3);  break; case 5:  //  XXX   //    X   curval = 120;  curpiece[0] = new Square(m  , rows - 1, 6);  curpiece[1] = new Square(m - 1, rows - 1, 6);  curpiece[2] = new Square(m + 1, rows - 1, 6);  curpiece[3] = new Square(m + 1, rows - 2, 6);  break; case 6:  //  XXX   //  X   curval = 120;  curpiece[0] = new Square(m  , rows - 1, 4);  curpiece[1] = new Square(m + 1, rows - 1, 4);  curpiece[2] = new Square(m - 1, rows - 1, 4);  curpiece[3] = new Square(m - 1, rows - 2, 4);  break; } lost = !movepiece(old, curpiece);} //  위로   // run()으로   // 현재조각의 이동 private synchronized boolean movecurpiece(int byx, int byy, boolean rotate) { Square newpos[] = new Square[4]; for (int i = 0; i<4; i++) {  if (rotate) {   int dx = curpiece[i].X() - curpiece[0].X();   int dy = curpiece[i].Y() - curpiece[0].Y();   newpos[i] = new Square(curpiece[0].X() - dy,    curpiece[0].Y() + dx,    curpiece[i].Color());  }  else   newpos[i] = new Square(curpiece[i].X() + byx,    curpiece[i].Y() + byy,    curpiece[i].Color()); } if (!movepiece(curpiece, newpos)) return false; curpiece = newpos; return true;} //  위로   // keyDown()으로   // 채워진 행 제거 private void removelines() {outerlabel: for (int j = 0; j<rows; j++) {  // j번째 라인 확인   for (int i = 0; i<cols; i++)   if (f[i][j] == 0)    continue outerlabel;  // j번째 라인제거   for (int k = j; k<rows - 1; k++)   for (int i = 0; i<cols; i++)    f[i][k] = f[i][k + 1];  // j번째 라인 재확인   j--; }} //  위로 
